## Volatile针对指令重排做了啥[#](https://www.cnblogs.com/qiuwenli/p/13513718.html#437597507)

Volatile实现禁止指令重排优化，从而避免了多线程环境下程序出现乱序执行的现象

首先了解一个概念，**内存屏障**（Memory Barrier）又称内存栅栏，是一个CPU指令，它的作用有两个：

- 保证特定操作的顺序
- 保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）
   由于编译器和处理器都能执行指令重排的优化，如果在指令键插入一条Memory  Barrier则会告诉编译器和CPU,不管什么指令都不能和这条Memory  Barrier指令重排序，也就是说，通过插入内存屏障前后的指令执行重排序优化。内存屏障另外一个作用是刷新出各种CPU的缓存数，因此任何cpu上的线程都能读取到这些数据的最新版本
   [![img](https://img2020.cnblogs.com/blog/1164910/202008/1164910-20200816171308095-1818218127.png)](https://img2020.cnblogs.com/blog/1164910/202008/1164910-20200816171308095-1818218127.png)
   也就是在Volatile的写和读的时候，加入屏障，防止出现指令重排

### 线程安全得到保证[#](https://www.cnblogs.com/qiuwenli/p/13513718.html#1463543348)

工作内存与主内存同步延迟现象导致的可见性问题

- 可以使用synchronized或volatile关键字解决，它们都可以使得一个线程修改后的变量立即对其他线程可见。
   对于指令重排导致的可见性问题和有序性问题
- 可以利用volatile关键字解决，因为volatile的另一个作用就是禁止重排序优化。