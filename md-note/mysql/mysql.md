# mysql

#### 1、利用show profile查看sql的执行周期:

> 修改配置文件letc/my.cnf
> 新增一行: query_cache_type=1
> 重启mysql
> 先开启show variables like 1%profiling%';
> set profiling=1;
> select * from xxX ;
> show profiles;#显示最近的几次查询

#### 2、查询流程:

> 首先，mysql的查询流程大致是:
> 找到这其中最好的执行计划。。
> omysql客户端通过协议与mysq服务器建连接，发送查询语句，先检查查询缓存，如果命中，直接返回结果，否则进行语句解析.也就是说，在解析查询之前，服务器会先访问查询缓存(query cache)——它存储SELECT语句以及相应的查询结果集。如果某个查询结果已经位于缓存中，服务器就不会再对查询进行解析、优化、以及执行。它仅仅将缓存中的结果返回给用户即可，这将大大提高系统的性能。
> ·语法解析器和预处理:首先mysqli通过关键字将SQL语句进行解析，并生成一颗对应的"解析树"。mysql解析器将使用mysqli语法规则验证和解析查询，预处理器则根据一些mysql规则进—步检查解析数是否合法。
>
> 查询优化器当解析树被认为是合法的了，并且由优化器将其转化成执行计划。一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是
>
> 然后，mysql默认使用的BTREE索引，并且一个大致方向是:无论怎么折腾sql，至少在目前来说，mysql最多只用到表中的一个索引。

#### 3、查询模板：

> SELECTDISTINCT
>
> ​		<select_list >
>
> FROM
> 		<left_table > <join_type >
>
> JOIN 
>
> ​	<right_table > 
>
> ON
>
> < join_condition >
>
> WHERE
>
> <where_condition >
>
> GROUP BY  #使用GROUP BY 查出的字段只能是GROUP BY后面跟着的字段
>
> <group_by_list >
>
> HAVING  #用来过滤bai由GROUP BY语句du返回的记录集。
>
> <having_condition >
>
> ORDERBY  #排序
>
> <order_by_condition >
>
> L工M工T  #分页
>
> <limit_number >

#### 4、存储引擎：

> **查看存储引擎：SHOW ENGINES;**
>
> 1、存储引擎默认是<font color=red>InnoDB，支持外键，支持事务，行锁，操作是只锁住某一行，不影响其他行的操作，适合高病发场景，缓存时不仅缓存索引，还缓存真实数据，对内存性能要求比较高，而且内存大小对性能有决定性的影响。</font>
>
> 2、还有比较重要的是<font color=red>MyISAM, 这种存储引擎不支持外键，不支持事物，而且加的是表锁，即使仅仅只操作某一条数据库记录，也会锁住整个表，不适合高并发场景，这种引擎缓存时只缓存索引，不缓存真实数据，节省了资源，消耗少，但是，只能应对简单的业务</font> 
>
> 3、Archive引擎
>
> Archive档案存储引擎只支持INSERT和SELECT操作，在MySQL5.1之前不支持索引。
>
> Archive表适合日志和数据采集类应用。
>
> 根据英文的测试结论来看，Archive表比MyISAM表要小大约75%，比支持事务处理的InnoDB表小大约83%。
>
> 4、Blackhole引擎
>
> Blackncbe引擎设有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。但服务器会记录Blaxkole表的日志，所以可以用
>
> 于复制微据到备库，或者简单地记录到日志。但这种应用方式会值到很多问题,因此并不推荐。
>
> 5、CSV引擎
>
> CSV引擎可以将普通的CSV文件作为MySQL的表来处理，但不支持索引。
>
> CSV引擎可以作为—种数据交换的机制，非常有用。
>
> CSV存储的数据直接可以在操作系统里，用文本编辑器，或者excel读取。
>
> 6、Memory引擎
>
> 如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用Memory表是非常有用。Memor表至少
>
> 比M/ISAM表要快一个数量级。
>
> 7、Federated引擎
>
> Federaled引擎是访问其他MySQL服务器的一个代理，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，
>
> 因此默认是禁用的。 

#### 5、索引： 

> 1、根据mysql官方表示，索引（index）是一种数据结构（B+TREE），可以理解为排好序的快速查找数据结构，一般来说索引本身也很大，不可能全部存储在内存中，所以索引往往是以一种文件的方式存放在硬盘上的。
>
> 2、优势：   类似于图书馆建数目索引，提高数据的检索效率，降低数据库的IO成本。通过索引对数据进行排序，降低数据排序的成本，降低了CPU的消耗。
>
> 3、劣势：虽然索引大大提高了查询的速度，但是在保存数据时还要保存一份索引进去，大大降低了写操作的速度，实际上索引也是一张表，保存了主键与索引字段，并且指向实体表的记录，所以索引列也是要占用空间的 
>
> 4\索引的类型：
>
> ​		**聚簇索引（主键索引）： 并不是一种单独的索引类型，而是一种数据存储方式， 数据行和相邻的简直聚簇的存储在一起** ， 
>
> ​		**非聚簇索引（非主键索引） ** 
>
> 5、查看索引：SHOW INDEX FROM `t_emp`
>
> ​	  创建索引:  CREATE INDEX ids_name ON `t_emp`(NAME)
>
> ​	  创建唯一索引：CREATE UNIQUE INDEX idx_empno ON `t_emp`(empno)
>
> 6、哪些情况需要创建索引： 
>
> ​			（1）、主键自动建立唯一索引
>
> ​			（2）、频繁操作为查询条件的字段应该建立索引
>
> ​			（3）、查询与其他表关联的字段，外键应该建立索引
>
> ​			（4）、单键/组合索引的选择问题，组合索引性价比更高
>
> ​			（5）、查询中排序的字段，排序字段所通过索引去访问将大大提高排序速度
>
> ​			（6）、查询中统计或者分组的字段
>
> 7、那些字段不需要创建索引
>
> ​			（1）、表的记录太少
>
> ​			（2）、经常增删改的表或者字段
>
> ​			（3）、where填见用不到的字段不创建索引
>
> ​			（4）、国旅行不好的不适合创建索引

## 事物

 **事务属性的种类：**  **传播行为、隔离级别、只读和事务超时**

**a)**  **传播行为定义了被调用方法的事务边界。**

| **传播行为**                  | **意义**                                                     |
| ----------------------------- | ------------------------------------------------------------ |
| **PROPERGATION_MANDATORY**    | **表示方法必须运行在一个事务中，如果当前事务不存在，就抛出异常** |
| **PROPAGATION_NESTED**        | **表示如果当前事务存在，则方法应该运行在一个嵌套事务中。否则，它看起来和 PROPAGATION_REQUIRED** **看起来没什么俩样** |
| **PROPAGATION_NEVER**         | **表示方法不能运行在一个事务中，否则抛出异常**               |
| **PROPAGATION_NOT_SUPPORTED** | **表示方法不能运行在一个事务中，如果当前存在一个事务，则该方法将被挂起** |
| **PROPAGATION_REQUIRED**      | **表示当前方法必须运行在一个事务中，如果当前存在一个事务，那么该方法运行在这个事务中，否则，将创建一个新的事务** |
| **PROPAGATION_REQUIRES_NEW**  | **表示当前方法必须运行在自己的事务中，如果当前存在一个事务，那么这个事务将在该方法运行期间被挂起** |
| **PROPAGATION_SUPPORTS**      | **表示当前方法不需要运行在一个是事务中，但如果有一个事务已经存在，该方法也可以运行在这个事务中** |